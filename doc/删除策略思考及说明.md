
- **Goods（商品）**: Goods 表与多个从属表存在外键关联，例如 GoodsLocation（商品-库位映射）、Inventory（库存记录）、DNDetail/ASNDetail（订单明细）等。如果未配置级联删除，直接删除 Goods 可能导致残留关联记录，造成外键约束错误或孤立数据。**改进建议**：对于仅属于 Goods 的从属对象（如 GoodsLocation、库存记录等），应在 ORM 的关系定义中启用 `cascade="all, delete-orphan"`，或在数据库层设置外键 **ON DELETE CASCADE**，以确保删除商品时相应子记录也被删除。另一方面，为维护数据一致性，若商品已有库存或交易记录，推荐使用 **RESTRICT** 策略禁止删除此商品（需先清理关联数据），或者将关联记录的商品外键设为可空并使用 **SET NULL**（删除商品时清除关联引用，但保留记录），以避免数据不一致。

- **GoodsLocation（商品库位）**: GoodsLocation 通常作为商品与库位的关联表。其外键指向 Goods 和 Location。若删除 Goods 或 Location 而未同步删除对应的 GoodsLocation，可能出现无效的关联。**改进建议**：在 ORM 模型中，对 GoodsLocation 与 Goods、Location 的关系启用级联删除（例如 Goods.locations_relationship `cascade="all, delete-orphan"`），或在数据库中为 GoodsLocation 的外键设置 **ON DELETE CASCADE**。这样，当商品或库位删除时，相关的 GoodsLocation 记录会自动删除，避免产生孤儿记录。

- **Inventory（库存）**: Inventory 记录通常包含商品和库位的库存数量（外键指向 Goods 和 Location）。如果直接删除 Goods 或 Location 而未处理 Inventory，将导致库存记录引用不存在的商品或库位。**改进建议**：一般不应在有库存时删除商品或库位，建议对 Goods 和 Location 采用 **RESTRICT** 策略（即有库存记录时禁止删除）。如必须允许删除，可对 Goods 和 Location 与 Inventory 的关系使用级联删除，使删除操作同步移除库存记录（或在数据库外键上 **ON DELETE CASCADE**）。但更好的做法是在删除商品或库位前确保相关库存已清零或转移，以保持数据正确。

- **Location（库位）**: Location 通常归属 Warehouse（仓库）（外键 Warehouse_id），并与 GoodsLocation、Inventory 等存在一对多关系。若删除 Warehouse 而未处理其下的 Location，会遗留无主的库位；删除 Location 而未清理相关库存或商品映射则会产生孤立记录。**改进建议**：对 Warehouse -> Location 关系可使用 `cascade="all, delete-orphan"`（或外键 ON DELETE CASCADE），以便在删除仓库时自动删除其下所有库位（前提是这些库位已无库存/关联数据）。删除单个库位前应确保无库存（或已转移），并同步删除 GoodsLocation 等关联。若系统需要严格数据完整性，可采用 **RESTRICT**（禁止删除仍有关联数据的库位），避免在库位尚有关联商品、库存或操作记录时被删除。

- **Warehouse（仓库）**: Warehouse 可能归属 Company（公司）并拥有多个 Location。删除 Warehouse 而未移除其下库位、库存将导致不一致。**改进建议**：在 Company -> Warehouse 的关系上，可考虑使用级联删除，以便删除公司时其仓库一并删除；同样在 Warehouse -> Location 关系上启用 `cascade="all, delete-orphan"` 确保移除仓库时自动清理库位数据。然而，应在仓库删除前转移或清空其中的库存和任务。若仓库内仍有库存或历史记录，推荐使用 **RESTRICT** 禁止删除，直到相关数据处理完毕，以避免误删重要数据。

- **TransferRecord（移库记录）**: TransferRecord 记录物品在库位间移动，通常引用 Goods、源库位和目标库位（以及经手人 Staff）。这些外键关联表（Goods、Location、Staff）在删除时若未处理 TransferRecord，会导致历史记录丢失或引用错误。**改进建议**：不应对 Goods、Location 或 Staff 设置级联删除至 TransferRecord（否则删除商品/库位/员工会一并删除移库历史，造成数据丢失）。应采用 **RESTRICT**（有限制删除）：如某商品/库位存在 TransferRecord，则禁止删除该记录的关联实体；必要时可允许 Staff 删除并将 TransferRecord 的人员外键设为 NULL（需字段可空），保留移库记录但表示人员已不存在。总之，要确保删除 Goods/Location/Staff 时，相关的 TransferRecord 要么一同删除（不推荐），要么明确禁止删除或解除关联，以维护数据完整性。

- **Supplier（供应商）**: Supplier 通常被 Goods（商品）或 ASN（预先送货通知）引用（如商品的供应商ID，ASN的发货方）。若删除 Supplier 而商品或 ASN 仍引用它，将导致引用无效。**改进建议**：不要对 Supplier 与 Goods/ASN 采用级联删除，避免删除供应商时误删商品或收货记录。默认应使用 **RESTRICT** 策略：当供应商尚有关联商品或 ASN 时禁止删除。若业务允许移除供应商并保留商品，可将 Goods、ASN 等的供应商外键设为可空并使用 **SET NULL**（删除供应商时清除其 ID，但保留商品/ASN）。这样确保删除供应商不会破坏已有的数据关联。

- **Staff（员工）**: Staff 账号可能被各种业务记录引用（如 SortingTask、PickingTask 等任务的负责人或操作日志）。若直接删除 Staff 而未处理这些引用，会造成记录引用不存在的员工。**改进建议**：避免对 Staff 与任务记录使用级联删除，因为这会删除相关业务数据。应选择 **RESTRICT** 策略，禁止删除仍在被任务或日志引用的员工账号；或者将相关记录中的员工外键设为可空，在删除员工时使用 **SET NULL** 清除引用（确保任务/日志仍保留，只是不再关联具体员工）。另外，Staff 通常归属 Department，如果部门删除也不应级联删除员工记录，而应采取类似的限制策略。

- **SortingTask（分拣任务）**: SortingTask 作为主任务实体，拥有多个明细（SortingTaskDetail）和状态日志（SortingTaskStatusLog）。如果删除 SortingTask 而未删除其明细和日志，将残留孤立数据。**改进建议**：在 SortingTask 与其 Details、StatusLogs 的一对多关系上启用 `cascade="all, delete-orphan"`，确保删除分拣任务时，其明细和日志记录也自动删除（ORM 级联或数据库外键 ON DELETE CASCADE）。如果 SortingTask 从属于某个 SortingBatch（批次），可以在 SortingBatch -> SortingTask 关系上也使用级联删除，以便删除批次时相关任务一并移除；否则应在存在任务时限制删除批次。确保级联配置完整可以避免手动逐层删除，提高数据一致性。

- **SortingTaskDetail（分拣任务明细）**: SortingTaskDetail 是 SortingTask 的子表，其生命周期依赖于父任务。若未设置级联，删除 SortingTask 后会遗留明细。**改进建议**：在 SortingTask -> SortingTaskDetail 关系中添加 `cascade="all, delete-orphan"`，确保删除任务时其明细自动删除；删除单条明细从任务列表移除时也会正确删除数据库记录。同时，避免对商品等外键使用级联删除至 SortingTaskDetail（不应因删除商品而删除历史任务明细），而应在商品有未完成任务明细时禁止删除商品，以保证记录完整。

- **SortingBatch（分拣批次）**: SortingBatch 可能作为多个 SortingTask 的汇总。删除 SortingBatch 而未处理旗下任务将导致任务无批次引用或遗留无效数据。**改进建议**：如果业务允许删除整个批次，可在 SortingBatch -> SortingTask 关系上配置 `cascade="all, delete-orphan"`，以便删除批次时自动删除所属的分拣任务（以及任务的明细和日志）。若希望保留任务，则应使用 **RESTRICT**（当批次下仍有任务时不允许删除批次，需先处理任务）。总之，确保批次删除不会留下孤立的任务记录。

- **SortingTaskStatusLog（分拣任务状态日志）**: 这是记录 SortingTask 状态变更的日志表，从属于 SortingTask。若删除 SortingTask 未同步删除其日志，将产生无效日志条目。**改进建议**：在 SortingTask -> SortingTaskStatusLog 关系中设置 `cascade="all, delete-orphan"`，保证删除任务时关联的状态日志也被删除。类似地，不应因相关人员或其他实体删除而丢失日志记录；例如如果日志关联 Staff，删除员工时应保留日志（可将日志的员工外键设为 NULL），而不是级联删除日志，以完整保留历史记录。

- **RemovalRecord（移除记录）**: RemovalRecord 记录商品库存的移除/报废，通常包含 Goods、Location 等外键。若删除 Goods 或 Location 却未同步处理 RemovalRecord，会导致记录引用的外键失效。**改进建议**：避免对 Goods、Location 级联删除 RemovalRecord（防止丢失历史记录）。相反，应在商品或库位存在 RemovalRecord 时禁止其删除（**RESTRICT**），除非先行处理这些移除记录。这样可确保历史数据完整，如需删除 Goods/Location，须先迁移或归档相关的 RemovalRecord。

- **Recipient（收件人）**: Recipient 常被配送/发货单（如 DN）引用，表示收货方信息。如果删除 Recipient 而相关配送记录仍引用它，将造成数据不完整。**改进建议**：对 Recipient 与配送记录的关系不要使用级联删除。应当在 Recipient 有关联 DN/DeliveryTask 等记录时禁止删除该收件人（RESTRICT），以保护历史记录的完整性。若业务需要删除收件人，可考虑确保其不再被任何记录引用，或者将引用改为 **SET NULL**（前提是配送记录另存有收件人详情，且外键允许为空），以免破坏既有数据关联。

- **PutawayRecord（上架记录）**: PutawayRecord 记录货物上架情况，通常引用 Goods/ASNDetail、目标 Location 和执行 Staff 等。删除相关 Goods、ASN 或 Location 而未处理 PutawayRecord 会导致记录指向失效的外键。**改进建议**：不要对 Goods、ASNDetail 或 Location 设置级联删除至 PutawayRecord，避免删除基础数据时丢失上架历史。通常在存在相关上架记录时，应禁止删除对应的商品、ASN 或库位（RESTRICT）。如果必须删除基础数据，则需先处理或转移对应的 PutawayRecord（例如调整关联的记录），以保证数据一致性和完整的操作追踪。

- **PickingTask（拣货任务）**: PickingTask 拥有拣货明细（PickingTaskDetail）和状态日志（PickingTaskStatusLog），并可能归属某个拣货批次（PickingBatch）。未正确配置级联删除时，删除拣货任务可能遗留明细或日志。**改进建议**：在 PickingTask -> PickingTaskDetail 及 PickingTask -> PickingTaskStatusLog 关系中启用 `cascade="all, delete-orphan"`，确保删除任务时明细和日志同步删除。如果存在 PickingBatch -> PickingTask 的关系，也应考虑级联删除，使删除批次时对应任务（及其子记录）一并删除；否则应在批次下有任务时禁止删除批次。这样可以保持任务数据的一致，不会留下孤立的拣货明细或日志。

- **PickingTaskDetail（拣货明细）**: PickingTaskDetail 是拣货任务的子记录，典型外键包括 PickingTask 和 Goods 等。应随父任务生命周期维护其存在。**改进建议**：确保 PickingTask -> PickingTaskDetail 关系设置了级联删除（delete-orphan），删除任务时对应明细自动清理。此外，不应因删除商品而随之删除历史拣货明细记录；相反，当商品存在未完成的拣货明细时应禁止删除该商品（RESTRICT），以维护订单履行记录的完整性。

- **PickingBatch（拣货批次）**: PickingBatch 汇总一组拣货任务。若删除批次未处理其下任务，任务记录将失去批次引用。**改进建议**：对 PickingBatch -> PickingTask 关系使用 `cascade="all, delete-orphan"`，确保删除批次时其包含的所有拣货任务及相关明细、日志都被删除。如果不希望自动删除任务，则应在批次有任务时禁止删除该批次（RESTRICT），只有在批次为空或任务已另行处理后才能删除。以此保证批次和任务数据一致。

- **PickingTaskStatusLog（拣货任务状态日志）**: 作为拣货任务的状态变更记录，其存在依赖对应的拣货任务。**改进建议**：配置 PickingTask -> PickingTaskStatusLog 关系的级联删除，删除任务时自动删除相关日志记录，避免遗留无效日志。同时，与其他日志类似，不应对日志的关联外键（如员工等）执行级联删除，以免丢失历史操作记录；当相关外键（如 Staff）被删除时，可将日志中的引用置空而保留日志。

- **Payment（支付）**: Payment 表可能关联订单、发货单 (DN) 或公司等。如果删除相关订单/DN 而支付记录未删除，会导致支付指向不存在的业务单据；反之删除 Payment 而订单仍引用付款信息也会不一致。**改进建议**：谨慎处理 Payment 的关联删除。通常不对订单或发货单级联删除 Payment，应该在存在支付记录时限制删除相关业务单据（RESTRICT），以确保财务数据留存。相应地，删除 Payment 记录也应确认没有业务记录依赖其存在。对于多租户系统，可在删除 Company 时级联删除其 Payment 数据（若需要清理整个平台数据），但平时应避免随意删除支付记录，确保账务一致。

- **PackingTask（打包任务）**: PackingTask 拥有打包明细（PackingTaskDetail）和状态日志（PackingTaskStatusLog），也可能归属于 PackingBatch 批次。若未配置级联删除，删除打包任务会残留对应的明细和日志。**改进建议**：在 PackingTask -> PackingTaskDetail 以及 PackingTask -> PackingTaskStatusLog 的关系中使用 `cascade="all, delete-orphan"`，确保删除任务时相关子记录一同删除。若存在 PackingBatch -> PackingTask 关系，也应考虑级联，以便删除批次时相关任务及其明细日志同步删除；否则应限制删除含有任务的批次。通过正确的级联配置，可避免产生孤立的打包明细或日志数据。

- **PackingTaskDetail（打包明细）**: PackingTaskDetail 是打包任务的子记录，包含具体包裹内物品的信息。**改进建议**：应确保 PackingTask -> PackingTaskDetail 关系配置了级联删除，这样在删除打包任务或移除某条明细时，PackingTaskDetail 会被相应删除，避免数据库中遗留无用记录。此外，与其他明细表类似，不建议因删除商品或订单而直接删除 PackingTaskDetail；若某商品存在未完成的打包明细引用，应暂时禁止删除该商品，以维持履约记录的完整。

- **PackingBatch（打包批次）**: PackingBatch 是打包任务的集合。删除批次如未清理其下任务，将导致任务记录不一致。**改进建议**：对 PackingBatch -> PackingTask 关系使用级联删除，以便删除批次时自动删除所有隶属的打包任务（及其明细、日志）。如果当前批次仍有关联任务，则应禁止删除该批次，除非任务已被处理或转移。这样确保批次与任务之间无不一致的残留数据。

- **PackingTaskStatusLog（打包任务日志）**: 记录打包任务状态变化的日志条目，应从属于对应的 PackingTask。**改进建议**：设置 PackingTask -> PackingTaskStatusLog 的级联删除，在删除打包任务时清除其日志记录。类似其他日志表，在人员等外键删除时不应级联移除日志，而应通过限制删除或置空引用保留日志，确保历史记录完整。

- **DN（发货单）**: DN（Delivery Note/配送单）通常有多个 DNDetail（发货明细）子记录，并关联 Recipient（收件人）、Carrier（承运商）等信息。删除 DN 而未处理 DNDetail 将遗留孤立的明细记录。**改进建议**：在 DN -> DNDetail 关系上启用 `cascade="all, delete-orphan"` 或数据库 ON DELETE CASCADE，确保删除发货单时对应明细一并删除，保持数据一致。此外，不应对 Recipient、Carrier 等外键使用级联删除到 DN（以免删除收件人/承运商时误删历史发货单）。正确做法是当 DN 存在时限制删除相关的收件人或承运商（RESTRICT），或者在必要时允许将 DN 的此类外键设为 NULL（如收件人被删但发货单保留地址副本）。确保发货单删除操作不会破坏与之相关的其他数据。

- **DNDetail（发货单明细）**: DNDetail 是发货单的子表，记录具体商品和数量。**改进建议**：DN -> DNDetail 需配置级联删除，以便删除发货单时明细同步删除。此外，DNDetail 通常引用 Goods 等基础数据，不应因商品删除而连带清除历史发货明细。相反，应在商品有相关发货记录时禁止删除该商品，以 **RESTRICT** 方式维护销售/配送记录的完整。如果确需删除商品，需确保没有 DNDetail 仍引用它。

- **Department（部门）**: Department 一般对应多个 Staff（员工）记录。若删除 Department 而未处理其员工，将导致员工记录的部门引用无效。**改进建议**：避免对 Department -> Staff 使用级联删除，以防误删员工数据。应在部门下仍有员工时禁止删除该部门（RESTRICT），除非这些员工已转移或无关联部门。或者可允许删除部门的同时将关联员工的部门外键设为 NULL（即 **SET NULL**，需员工记录的 department_id 可为空），保留员工但表示其不属于任何部门。此举确保删除部门不会导致员工记录不一致。

- **DeliveryTask（配送任务）**: DeliveryTask 负责运输配送，可能对应某张发货单 (DN) 或多个包裹，并拥有状态日志（DeliveryTaskStatusLog）。若删除 DeliveryTask 未级联删除日志，将残留无意义的状态记录。**改进建议**：在 DeliveryTask -> DeliveryTaskStatusLog 关系中设置 `cascade="all, delete-orphan"`，以便删除配送任务时自动移除其日志记录。若 DeliveryTask 与 DN 存在一对一关系，删除发货单时应考虑同时删除配送任务（可通过适当的关联级联或逻辑删除实现），避免出现无关联的配送任务。对于关联的人员外键（如配送员 Staff），也应避免级联删除任务；删除人员时可重新指派任务或在任务完成后再删除人员账号，以维护数据完整。

- **DeliveryTaskStatusLog（配送任务日志）**: 属于 DeliveryTask 的操作日志。**改进建议**：确保 DeliveryTask 删除时该日志记录一并删除（通过级联关系实现）。同时，和其他日志类似，不应因关联实体（如人员）删除而移除日志；应保留日志记录，将相关引用设空或采取限制删除策略，以保障运输过程的历史追溯。

- **CycleCountTask（循环盘点任务）**: CycleCountTask 具有盘点明细（CycleCountTaskDetail）和状态日志（CycleCountTaskStatusLog）。如果删除盘点任务未处理其子记录，会导致盘点明细和日志遗留。**改进建议**：为 CycleCountTask -> CycleCountTaskDetail 以及 CycleCountTask -> CycleCountTaskStatusLog 关系启用 `cascade="all, delete-orphan"`，确保删除盘点任务时，其明细和日志同步删除。若盘点任务关联特定库位或区域，在该库位删除时应禁止删除仍未完成的盘点任务（RESTRICT），而不应级联删除盘点任务，以免丢失库存盘点记录。

- **CycleCountTaskDetail（盘点任务明细）**: 盘点任务的明细记录，通常列示需要清点的商品、库位等。**改进建议**：CycleCountTask -> CycleCountTaskDetail 关系应配置级联删除，以便盘点任务删除时明细自动清理。与此同时，不应因基础数据删除（如商品或库位）而直接移除相关盘点明细记录；如果某商品/库位正被盘点任务引用，应暂时避免删除该基础数据，确保盘点流程完整。

- **CycleCountTaskStatusLog（盘点任务日志）**: 属于盘点任务的状态/操作日志。**改进建议**：应随着 CycleCountTask 的删除而删除，可通过级联关系保证这一点。和其它日志类似，日志本身没有下属数据，但在涉及到关联人员等时，删除人员不应影响已有日志的存留，应通过限制删除或置空引用来保留这些历史信息。

- **Company（公司）**: Company 常作为顶级实体，拥有 Warehouse、Staff、Department、Recipient、Supplier 等子数据。在删除 Company 时，需要处理其名下的所有关联记录。**改进建议**：若需物理删除 Company 及其所有数据，可在 Company 与 Warehouse、Staff、Department 等一对多关系上使用 `cascade="all, delete-orphan"`（或数据库 ON DELETE CASCADE）配置，实现删除公司时级联删除旗下所有相关记录。这要求各级关联（仓库 -> 库位 -> 库存/任务等）也正确设置级联，以避免遗留孤数据。相反，在生产环境中通常采用 **RESTRICT** 策略：只有当公司没有关联的子记录时才允许删除，以防误删整套业务数据。可以考虑提供批量清理逻辑或“软删除”（标记无效）来安全地移除 Company 及其数据。

- **Carrier（承运商）**: Carrier 一般被发货单 (DN) 等引用。删除 Carrier 而已有 DN 仍引用它会造成数据不一致。**改进建议**：不要对 Carrier -> DN 使用级联删除（避免删除承运商时连带删掉历史发货单）。应在承运商仍被任何运输/发货记录引用时禁止删除该承运商（RESTRICT）。如果需要删除承运商，可确保所有关联的发货记录已结束或更新，将相关 DN 的承运商外键置空或改为其他承运商，然后再删除。这样既维护了运输记录，又避免了无效引用。

- **ASN（到货通知）**: ASN (预先通知单) 拥有多个 ASNDetail（到货明细）子记录，可能关联 Supplier（供应商）等。删除 ASN 而未删除其明细会遗留孤立 ASNDetail。**改进建议**：在 ASN -> ASNDetail 关系上使用 `cascade="all, delete-orphan"`，保证删除通知单时其明细同步删除。对于 ASN 引用的 Supplier，不应使用级联删除（不因删除供应商而删掉通知单）；如供应商有未完成的 ASN，则应限制删除该供应商。类似地，只有在 ASN 没有未处理记录时才能删除 ASN 所属的上级实体（如公司或仓库）。通过恰当的级联配置和删除约束，可确保 ASN 删除操作不会破坏其关联数据。

- **ASNDetail（到货明细）**: ASNDetail 是 ASN 的子记录，列出预期到货的商品及数量。**改进建议**：应配置 ASN -> ASNDetail 的级联删除，以在删除通知单时清理其所有明细记录。ASNDetail 通常引用 Goods 等基础资料，不应对 Goods 采用级联删除至 ASNDetail（以免删除商品时丢失到货历史）。正确做法是在商品存在相关 ASNDetail 时禁止删除该商品（RESTRICT），确保到货记录的完整性。

- **Adjustment（库存调整）**: Adjustment 表示库存调整记录，通常有多个 AdjustmentDetail（调整明细）。若删除 Adjustment 未同步删除其明细，将导致调整详情孤立。**改进建议**：在 Adjustment -> AdjustmentDetail 关系上启用 `cascade="all, delete-orphan"`，以便删除调整记录时一并移除相关明细。Adjustment 记录可能引用执行人（Staff）、仓库/库位或商品；不应级联删除这些基础数据到 Adjustment（避免删除基础数据导致历史调整记录丢失）。一般在有关联的 Adjustment 时禁止删除对应的商品或库位，以维护账目追踪完整。对于删除 Company 操作，可级联删除其 Adjustment 历史（整帐簿清理），但平时调整记录应保留以供审计。

- **AdjustmentDetail（调整明细）**: AdjustmentDetail 归属 Adjustment，记录具体库存增减项（关联 Goods、Location 等）。**改进建议**：应确保 Adjustment -> AdjustmentDetail 关系配置了级联删除，这样删除调整单时相关明细也被删除。对于 AdjustmentDetail 引用的商品、库位等，不应对其使用级联删除（不会因为删除商品就自动删调整明细）；相应地，当某商品或库位存在未结的调整明细时，应暂缓删除该实体，直至调整记录处理完毕，以保证库存账目不出现遗漏。



下面给出基于 WMS 行业最佳实践的删除策略说明。总体来说，WMS 系统中有两大类数据：

1. **主数据（Master Data）**  
   如商品（Goods）、仓库（Warehouse）、库位（Location）、公司（Company）、供应商（Supplier）、收件人（Recipient）、承运商（Carrier）、部门（Department）以及员工（Staff）等，这些数据一般不建议直接物理删除。最佳实践是采用**软删除**（例如通过 is_active 标识）来标记记录失效，从而保留历史和审计痕迹。如果确实需要物理删除，通常建议：  
   - **RESTRICT（限制删除）**：当存在引用（例如历史交易、库存记录、订单记录）时禁止删除。  
   - 或者采用 **SET NULL**（将关联外键置空），前提是业务允许断开关联，并且外键字段允许为空。  
   - 对于依赖关系明确、且子记录仅用于描述主记录的场景，也可在 ORM 关系中配置级联删除（CASCADE），但要非常谨慎，避免误删历史数据。

2. **事务数据及历史记录（Transactional / Historical Data）**  
   如库存（Inventory）、移库记录（TransferRecord）、拣货、分拣、打包任务及其明细、发货单（DN）、到货通知（ASN）、支付记录（Payment）、调整记录（Adjustment）等，这类数据往往需要完整保留以便追踪操作和审计。  
   - **物理删除时**，如果确实需要删除某个父记录，则其下属的子记录（例如任务明细、状态日志等）应通过 ORM 的级联删除（`cascade="all, delete-orphan"`）自动清理。  
   - 但通常建议采用**软删除**，保持数据历史完整性，不建议轻易物理删除这些关键交易数据。

下面给出一些常见模型及其删除策略示例（仅供参考）：

---

### 示例 1：主数据（例如 Goods）

**推荐做法**  
- 使用软删除：记录中保留 `is_active` 标识，不进行物理删除。  
- 如果允许物理删除，建议对依赖于 Goods 的子表（例如 GoodsLocation、Inventory）配置级联删除；而对引用 Goods 的历史记录（例如订单、发货单明细）则采用 RESTRICT 或 SET NULL。

**代码示例**（Goods 模型）：

```python
from extensions.db import *

class Goods(db.Model):
    __tablename__ = 'goods'
    __table_args__ = (
        db.UniqueConstraint('code', 'company_id', name='uix_code_company'),
    )

    id = db.Column(db.Integer, primary_key=True)
    company_id = db.Column(db.Integer, db.ForeignKey('companies.id', ondelete='RESTRICT'), nullable=False)
    code = db.Column(db.String(50), nullable=False)
    name = db.Column(db.String(100), nullable=False)
    # ... 其他字段 ...
    is_active = db.Column(db.Boolean, default=True)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=db.func.now())
    updated_at = db.Column(db.DateTime, default=db.func.now(), onupdate=db.func.now())

    # 关系设置：
    # 主数据一般不采用级联删除到历史记录，避免误删已交易数据
    company = db.relationship('Company', backref=db.backref('goods', lazy=True))
    
    # 对于与 Goods 紧密相关的子对象，可以采用级联删除
    storage_records = db.relationship('GoodsLocation', backref='goods', lazy=True, cascade='all, delete-orphan')
    inventories = db.relationship('Inventory', back_populates='goods', lazy=True, cascade='all, delete-orphan')
    # 创建者关系通常不级联删除
    creator = db.relationship('User', backref='goods_created', lazy=True)
```

---

### 示例 2：事务数据（例如 SortingTask 及其明细）

**推荐做法**  
- 事务数据通常采用软删除来保留操作记录；  
- 如果进行物理删除，父任务删除时需要级联删除下属的任务明细、批次记录和状态日志。

**代码示例**（部分 SortingTask 模型）：

```python
class SortingTask(db.Model):
    __tablename__ = 'sorting_tasks'
    id = db.Column(db.Integer, primary_key=True)
    asn_id = db.Column(db.Integer, db.ForeignKey('asn.id'), nullable=False)
    status = db.Column(db.Enum('pending', 'in_progress', 'completed', name='sorting_task_status_enum'),
                       nullable=False, default='pending')
    is_active = db.Column(db.Boolean, default=True)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=db.func.now())
    updated_at = db.Column(db.DateTime, default=db.func.now(), onupdate=db.func.now())
    # 级联删除任务明细、批次和状态日志
    task_details = db.relationship('SortingTaskDetail', backref='sorting_task', lazy=True,
                                   cascade='all, delete-orphan')
    batches = db.relationship('SortingBatch', backref='sorting_task', lazy=True,
                              cascade='all, delete-orphan')
    status_logs = db.relationship('SortingTaskStatusLog', backref='task', lazy=True,
                                  cascade='all, delete-orphan')
    # 其他关系
```

---

### 示例 3：引用历史记录的事务数据（例如 DN 与 DNDetail）

**推荐做法**  
- 发货单（DN）及其明细作为历史记录，不建议物理删除；若确实删除 DN，应采用级联删除 DNDetail；  
- 同时，对引用 DN 的其他业务单据（如 DeliveryTask）采用 RESTRICT 策略，确保历史数据完整。

**代码示例**（部分 DN 模型）：

```python
class DN(db.Model):
    __tablename__ = 'dn'
    id = db.Column(db.Integer, primary_key=True)
    warehouse_id = db.Column(db.Integer, db.ForeignKey('warehouses.id', ondelete='RESTRICT'), nullable=False)
    recipient_id = db.Column(db.Integer, db.ForeignKey('recipients.id', ondelete='RESTRICT'), nullable=False)
    # ... 其他字段 ...
    is_active = db.Column(db.Boolean, default=True)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=db.func.now())
    updated_at = db.Column(db.DateTime, default=db.func.now(), onupdate=db.func.now())

    # 级联删除明细：删除 DN 时自动删除其 DNDetail 记录
    details = db.relationship('DNDetail', backref='dn', lazy=True,
                              cascade='all, delete-orphan')
```

---

### 行业最佳实践总结

- **主数据（Goods、Warehouse、Location、Company、Supplier、Recipient、Carrier、Department、Staff 等）**  
  - **软删除** 为首选：通过 `is_active` 标识，保留历史信息。  
  - 如果需要物理删除，则通常设置外键为 **RESTRICT**，防止误删历史数据；在必要时可以使用 **SET NULL**（要求外键字段允许为 NULL）。

- **事务数据及历史记录（Inventory、TransferRecord、SortingTask、DN、ASN、Payment、Adjustment 等）**  
  - **不建议物理删除**，推荐使用软删除；  
  - 如果业务确实需要物理删除，则在父子关系上配置 ORM 级联删除（`cascade="all, delete-orphan"`），确保删除父记录时自动清理所有依赖数据，同时确保外键策略（如 ondelete='CASCADE'）与数据库行为一致。

- **日志与操作记录**  
  - 日志数据（状态日志、任务明细等）通常应保留，不建议删除；如必须删除，需谨慎配置级联删除，或采用归档策略。

总体而言，WMS 系统数据高度依赖历史记录和追踪信息，**软删除**是行业内最常见且安全的做法；在无法避免物理删除时，应采用合适的外键删除策略（CASCADE、SET NULL、RESTRICT）以及 ORM 层的级联设置，确保数据一致性和业务安全性。

以上即为根据 WMS 行业最佳实践对各模型删除策略的建议。


在 SQLAlchemy 中，可以在两层体现删除策略：

1. **数据库层面的外键约束**  
   在 `db.ForeignKey` 中设置 `ondelete` 参数，以告诉数据库如何处理父记录删除时的子记录。例如：  
   - **CASCADE**：当父记录删除时，数据库自动删除所有引用该记录的子记录。  
   - **SET NULL**：当父记录删除时，将子记录中对应的外键字段设置为 `NULL`（前提是该字段允许为空）。  
   - **RESTRICT**：不允许删除父记录（如果有子记录存在），数据库会报错阻止删除操作。

2. **ORM 级别的级联删除**  
   在 `db.relationship` 中使用 `cascade` 参数，告诉 SQLAlchemy 在删除对象时如何级联处理其关联的子对象。常见用法有 `cascade='all, delete-orphan'`，表示删除父对象时，其所有“孤儿”子对象也被删除。

下面给出代码示例：

---

### 1. CASCADE 示例

```python
from extensions.db import *

class Parent(db.Model):
    __tablename__ = 'parents'
    id = db.Column(db.Integer, primary_key=True)
    # 定义与子对象的关系，并启用级联删除
    children = db.relationship('Child', backref='parent', cascade='all, delete-orphan')

class Child(db.Model):
    __tablename__ = 'children'
    id = db.Column(db.Integer, primary_key=True)
    # 外键中设置 ondelete='CASCADE'
    parent_id = db.Column(db.Integer, db.ForeignKey('parents.id', ondelete='CASCADE'), nullable=False)
```

在这个示例中：  
- 数据库层面，删除 Parent 记录时，数据库会自动删除所有关联的 Child 记录（需要数据库支持 CASCADE）。  
- ORM 层面，`cascade='all, delete-orphan'` 确保通过 ORM 删除 Parent 时，其 Child 对象也会被删除。

---

### 2. SET NULL 示例

```python
from extensions.db import *

class Parent(db.Model):
    __tablename__ = 'parents'
    id = db.Column(db.Integer, primary_key=True)
    # 这里可以选择不配置 cascade，如果希望保留子记录
    children = db.relationship('Child', backref='parent')

class Child(db.Model):
    __tablename__ = 'children'
    id = db.Column(db.Integer, primary_key=True)
    # 允许为空，并设置 ondelete='SET NULL'
    parent_id = db.Column(db.Integer, db.ForeignKey('parents.id', ondelete='SET NULL'), nullable=True)
```

在这个示例中：  
- 当删除 Parent 记录时，数据库会将所有引用该 Parent 的 Child 记录的 `parent_id` 设置为 `NULL`，从而保留子记录但解除关联。

---

### 3. RESTRICT 示例

```python
from extensions.db import *

class Parent(db.Model):
    __tablename__ = 'parents'
    id = db.Column(db.Integer, primary_key=True)
    # 这里通常不配置 cascade，以防止误删子记录
    children = db.relationship('Child', backref='parent')

class Child(db.Model):
    __tablename__ = 'children'
    id = db.Column(db.Integer, primary_key=True)
    # 明确设置 ondelete='RESTRICT' 或者不设置 ondelete（数据库默认通常为 RESTRICT）
    parent_id = db.Column(db.Integer, db.ForeignKey('parents.id', ondelete='RESTRICT'), nullable=False)
```

在这个示例中：  
- 当存在关联的 Child 记录时，尝试删除 Parent 记录会被数据库阻止（RESTRICT），以维护数据完整性。

---

### 小结

- **数据库层面**：通过 `ondelete` 参数指定删除策略。  
- **ORM 层面**：通过 `cascade` 参数指定在 ORM 操作时如何级联处理子对象。  
- 根据业务需求选择合适的策略：  
  - 若希望删除父记录时同时删除所有子记录，则使用 **CASCADE**。  
  - 若希望保留子记录但解除与父记录的关联，则使用 **SET NULL**（确保外键字段允许为 NULL）。  
  - 若不希望父记录被删除（当有子记录存在时），则使用 **RESTRICT**（或不设置 ondelete，让数据库默认拒绝删除操作）。

这样，在代码中就体现了不同的删除策略。